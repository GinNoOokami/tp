# Beginning Actor Decompilation: A Guided Example

## Introduction

This tutorial will guide you through the decompilation of a simple actor class in Zelda: Twilight Princess. The goal is to demonstrate what the process looks like from start to finish using a real example from the game, to impart some knowledge about common patterns used in the code, and teach some basic decompilation strategies and techniques that can be used in your own decompilation journey.

## Before you begin

A basic understanding of C++ will be beneficial to get the most out of this guide.

It's important to keep in mind that while many share common patterns and similarities, each actor is different. What may work as a strategy in one may not in another. Decompiling heavily optimized C++ code can be a complex and nuanced process, with dependencies that may not be resolved until part or even all of the [Translation Unit](https://en.wikipedia.org/wiki/Translation_unit_(programming)) (TU) is fully decompiled.

Rather that treat the steps outlined by this guide as a universal strategy which can be applied to any actor, treat it as it as a set of loose guidelines.

With the preamble out of the way, let's begin!

## Starting out

This guide will focus on the d_a_obj_saidan actor, which is considered a `rel`. For context, this actor represents the movable altar you find in the sanctuary at Kakariko village. Let's briefly go over some terminology here:

* Actor: An entity within the game world. This can be an object, the player, an enemy, an npc, or even just a piece of logic. Always extends from the `fopAc_ac_c` base actor class somewhere in the inheritance chain, but there are a few different subclasses of this. We'll explore one of them in this guide.
* rel: Each actor is represented as a piece of executable code called a "rel". These can be swapped in an out of memory as needed, like [overlays](https://en.wikipedia.org/wiki/Overlay_(programming)).

For those who prefer to follow along, the full path is `rel/d/a/obj/d_a_obj_saidan/d_a_obj_saidan.cpp`.

All files that have not yet been decomped follow a similar structure which was autogenerated by a tool called `dol2asm`. Let's examine the main sections of the file:

* Types: Most of these types are just stubs needed for the TU to successfully compile against, and will be removed as you pull in the necessary header files.
* Forward references: These are the mangled forward declarations for the symbols defined by the actor. They are necessary for the asm chunks to compile successfully. Can be removed once decomp is complete.
* External references: These are the mangled external references that are used by the class. Eventually these will all be removed, some sooner than others.
* Declarations: This is where things get interesting. This section can contain a mix of `.bss`, `.data`, `.rodata`, and `.text`. In plain language, it will contain mutable static data, readonly static data (literals), uninitialized static variables, and code.

## How big is it?

A good starting point is determining the size of the class. There are a few ways to accomplish this, but fortunately for us, one of them towers above the rest in its simplicity. The original devs included debug information for each actor which was presumably used for profiling game performance, and as you've probably guessed, the size is included as part of that data.

Find the symbol `g_profile_Obj_Saidan` and look at the fifth element of this array.

```C++
/* 80CC45D4-80CC4604 -00001 0030+00 0/0 0/0 1/0 .data            g_profile_Obj_Saidan */
SECTION_DATA extern void* g_profile_Obj_Saidan[12] = {
    (void*)0xFFFFFFFD, (void*)0x0003FFFD,
    (void*)0x00400000, (void*)&g_fpcLf_Method,
    (void*)0x000005B4, (void*)NULL,
    (void*)NULL,       (void*)&g_fopAc_Method,
    (void*)0x01FC0000, (void*)&l_daSaidan_Method,
    (void*)0x00040000, (void*)0x000E0000,
};
```

That `0x5B4` represents the total size. Don't worry about the rest of this data for now, we'll revisit it later. Let's add that to the class structure. Speaking of, what is the class name? If you glance through the file, tThere are two candidates: `daSaidan_c` and `daSaidan_HIO_c`. It's the former; the latter is a special type of companion class that accompanies some actor classes, which we will examine more in detail in the following section.

```C++
struct daSaidan_c {
    /* 80CC3E28 */ void setBaseMtx();
    // ...
    /* 80CC43BC */ void Delete();
}; // Size: 0x5B4

STATIC_ASSERT(sizeof(daSaidan_c) == 0x5B4);
```

## Shaping the data

Lorum ipsum

## Cleaning out the cruft

Lorum ipsum
